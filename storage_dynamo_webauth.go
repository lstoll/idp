package main

import (
	"bytes"

	"github.com/duo-labs/webauthn/webauthn"
)

const (
	emailKeyPrefix  = "email#"
	userIdAttribute = "user_id"
)

var _ webauthn.User = (*DynamoWebauthnUser)(nil)

type DynamoWebauthnUser struct {
	// ID uniquely identifies the user, and is assigned by the storage
	// implementation. This is stable for the life of the user
	ID string `dynamodbav:"id,omitempty"`
	// Email address for the user. This is changeable, however must be unique as
	// it's the "exposed" ID for a user for login purposes
	Email string `dynamodbav:"email,omitempty"`
	// FullName to refer to the user as
	FullName string `dynamodbav:"fullname,omitempty"`
	// Credentials for webauthn authenticators
	Credentials []DynamoWebauthnCredential `dynamodbav:"credentials,omitempty"`
}

// User ID according to the Relying Party
func (d *DynamoWebauthnUser) WebAuthnID() []byte {
	return []byte(d.ID)
}

// User Name according to the Relying Party
func (d *DynamoWebauthnUser) WebAuthnName() string {
	return d.Email
}

// Display Name of the user
func (d *DynamoWebauthnUser) WebAuthnDisplayName() string {
	return d.FullName
}

// User's icon url
func (d *DynamoWebauthnUser) WebAuthnIcon() string {
	return ""
}

// Credentials owned by the user
func (d *DynamoWebauthnUser) WebAuthnCredentials() []webauthn.Credential {
	ret := []webauthn.Credential{}
	for _, c := range d.Credentials {
		wc := webauthn.Credential{
			ID:              c.ID,
			PublicKey:       c.PublicKey,
			AttestationType: c.AttestationType,
			Authenticator:   webauthn.Authenticator(c.Authenticator),
		}
		ret = append(ret, wc)
	}
	return ret
}

func (d *DynamoWebauthnUser) AddWebauthnCredential(name string, c *webauthn.Credential) {
	d.Credentials = append(d.Credentials, DynamoWebauthnCredential{
		Name:            name,
		ID:              c.ID,
		PublicKey:       c.PublicKey,
		AttestationType: c.AttestationType,
		Authenticator:   DynamoWebauthnAuthenticator(c.Authenticator),
	})
}

func (d *DynamoWebauthnUser) UpdateWebauthnCredential(c *webauthn.Credential) {
	for _, sc := range d.Credentials {
		if !bytes.Equal(c.ID, sc.ID) {
			sc.Authenticator = DynamoWebauthnAuthenticator(c.Authenticator)
		}
	}
}

func (d *DynamoWebauthnUser) DeleteWebauthnCredential(id []byte) {
	sc := []DynamoWebauthnCredential{}
	for _, c := range d.Credentials {
		if !bytes.Equal(c.ID, id) {
			sc = append(sc, c)
		}
	}
	d.Credentials = sc
}

// DynamoWebauthnCredential is a local version of webauthn.Credential, that we
// can tag for dynamo insertion
type DynamoWebauthnCredential struct {
	// A probabilistically-unique byte sequence identifying a public key credential source and its authentication assertions.
	ID []byte `dynamodbav:"id"`
	// The public key portion of a Relying Party-specific credential key pair, generated by an authenticator and returned to
	// a Relying Party at registration time (see also public key credential). The private key portion of the credential key
	// pair is known as the credential private key. Note that in the case of self attestation, the credential key pair is also
	// used as the attestation key pair, see self attestation for details.
	PublicKey []byte `dynamodbav:"public_key"`
	// The attestation format used (if any) by the authenticator when creating the credential.
	AttestationType string `dynamodbav:"attestation_type"`
	// The Authenticator information for a given certificate
	Authenticator DynamoWebauthnAuthenticator `dynamodbav:"authenticator"`
	/* end required duo/webauthn fields */
	// Name is a friendly way to refer to this credential in the UI
	Name string
}

// DynamoWebauthnAuthenticator is a localversion of webauthn.Authenticator, that
// we can tag for dynamo insertion
type DynamoWebauthnAuthenticator struct {
	// The AAGUID of the authenticator. An AAGUID is defined as an array containing the globally unique
	// identifier of the authenticator model being sought.
	AAGUID []byte `dynamodbav:"aaguid"`
	// SignCount -Upon a new login operation, the Relying Party compares the stored signature counter value
	// with the new signCount value returned in the assertionâ€™s authenticator data. If this new
	// signCount value is less than or equal to the stored value, a cloned authenticator may
	// exist, or the authenticator may be malfunctioning.
	SignCount uint32 `dynamodbav:"sign_count"`
	// CloneWarning - This is a signal that the authenticator may be cloned, i.e. at least two copies of the
	// credential private key may exist and are being used in parallel. Relying Parties should incorporate
	// this information into their risk scoring. Whether the Relying Party updates the stored signature
	// counter value in this case, or not, or fails the authentication ceremony or not, is Relying Party-specific.
	CloneWarning bool `dynamodbav:"clone_warning"`
}

/* storage interface */
