package main

import (
	"context"
	"fmt"
	"strings"

	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/service/dynamodb"
	"github.com/aws/aws-sdk-go/service/dynamodb/dynamodbattribute"
	"github.com/duo-labs/webauthn/webauthn"
	"github.com/google/uuid"
)

const (
	emailKeyPrefix  = "email#"
	userIdAttribute = "user_id"
)

var _ webauthn.User = (*DynamoWebauthnUser)(nil)

type DynamoWebauthnUser struct {
	// ID uniquely identifies the user, and is assigned by the storage
	// implementation. This is stable for the life of the user
	ID string `dynamodbav:"id,omitempty"`
	// Email address for the user. This is changeable, however must be unique as
	// it's the "exposed" ID for a user for login purposes
	Email string `dynamodbav:"email,omitempty"`
	// FullName to refer to the user as
	FullName string `dynamodbav:"fullname,omitempty"`
	// Credentials for webauthn authenticators
	Credentials []DynamoWebauthnCredential `dynamodbav:"credentials,omitempty"`
}

// User ID according to the Relying Party
func (d *DynamoWebauthnUser) WebAuthnID() []byte {
	return []byte(d.ID)
}

// User Name according to the Relying Party
func (d *DynamoWebauthnUser) WebAuthnName() string {
	return d.Email
}

// Display Name of the user
func (d *DynamoWebauthnUser) WebAuthnDisplayName() string {
	return d.FullName
}

// User's icon url
func (d *DynamoWebauthnUser) WebAuthnIcon() string {
	return ""
}

// Credentials owned by the user
func (d *DynamoWebauthnUser) WebAuthnCredentials() []webauthn.Credential {
	ret := []webauthn.Credential{}
	for _, c := range d.Credentials {
		wc := webauthn.Credential{
			ID:              c.ID,
			PublicKey:       c.PublicKey,
			AttestationType: c.AttestationType,
			Authenticator:   webauthn.Authenticator(c.Authenticator),
		}
		ret = append(ret, wc)
	}
	return ret
}

// DynamoWebauthnCredential is a local version of webauthn.Credential, that we
// can tag for dynamo insertion
type DynamoWebauthnCredential struct {
	// A probabilistically-unique byte sequence identifying a public key credential source and its authentication assertions.
	ID []byte `dynamodbav:"id"`
	// The public key portion of a Relying Party-specific credential key pair, generated by an authenticator and returned to
	// a Relying Party at registration time (see also public key credential). The private key portion of the credential key
	// pair is known as the credential private key. Note that in the case of self attestation, the credential key pair is also
	// used as the attestation key pair, see self attestation for details.
	PublicKey []byte `dynamodbav:"public_key"`
	// The attestation format used (if any) by the authenticator when creating the credential.
	AttestationType string `dynamodbav:"attestation_type"`
	// The Authenticator information for a given certificate
	Authenticator DynamoWebauthnAuthenticator `dynamodbav:"authenticator"`
}

// DynamoWebauthnAuthenticator is a localversion of webauthn.Authenticator, that
// we can tag for dynamo insertion
type DynamoWebauthnAuthenticator struct {
	// The AAGUID of the authenticator. An AAGUID is defined as an array containing the globally unique
	// identifier of the authenticator model being sought.
	AAGUID []byte `dynamodbav:"aaguid"`
	// SignCount -Upon a new login operation, the Relying Party compares the stored signature counter value
	// with the new signCount value returned in the assertionâ€™s authenticator data. If this new
	// signCount value is less than or equal to the stored value, a cloned authenticator may
	// exist, or the authenticator may be malfunctioning.
	SignCount uint32 `dynamodbav:"sign_count"`
	// CloneWarning - This is a signal that the authenticator may be cloned, i.e. at least two copies of the
	// credential private key may exist and are being used in parallel. Relying Parties should incorporate
	// this information into their risk scoring. Whether the Relying Party updates the stored signature
	// counter value in this case, or not, or fails the authentication ceremony or not, is Relying Party-specific.
	CloneWarning bool `dynamodbav:"clone_warning"`
}

/* storage interface */

func (d *DynamoStore) GetUserByID(ctx context.Context, id string) (*DynamoWebauthnUser, bool, error) {
	result, err := d.client.GetItemWithContext(ctx, &dynamodb.GetItemInput{
		TableName: &d.webauthnUserTableName,
		Key: map[string]*dynamodb.AttributeValue{
			"id": {
				S: &id,
			},
		},
	})
	if err != nil {
		return nil, false, fmt.Errorf("getting user %s: %v", id, err)
	}
	if result.Item == nil {
		return nil, false, nil
	}

	ret := DynamoWebauthnUser{}
	if err := dynamodbattribute.UnmarshalMap(result.Item, &ret); err != nil {
		return nil, false, fmt.Errorf("unmarshaling user %s: %v", id, err)
	}

	return &ret, true, nil
}

func (d *DynamoStore) GetUserByEmail(ctx context.Context, email string) (*DynamoWebauthnUser, bool, error) {
	k := emailKey(email)

	result, err := d.client.GetItemWithContext(ctx, &dynamodb.GetItemInput{
		TableName: &d.webauthnUserTableName,
		Key: map[string]*dynamodb.AttributeValue{
			"id": {
				S: &k,
			},
		},
	})
	if err != nil {
		return nil, false, fmt.Errorf("getting user email record %s: %v", email, err)
	}
	if result.Item == nil {
		return nil, false, nil
	}

	userid := result.Item[userIdAttribute].S
	if userid == nil {
		return nil, false, fmt.Errorf("user email %s has nil %s", email, userIdAttribute)
	}

	result, err = d.client.GetItemWithContext(ctx, &dynamodb.GetItemInput{
		TableName: &d.webauthnUserTableName,
		Key: map[string]*dynamodb.AttributeValue{
			"id": {
				S: userid,
			},
		},
	})
	if err != nil {
		return nil, false, fmt.Errorf("getting user id %s: %v", *userid, err)
	}
	if result.Item == nil {
		return nil, false, fmt.Errorf("email %s refers to unfound user %s", email, *userid)
	}

	ret := DynamoWebauthnUser{}
	if err := dynamodbattribute.UnmarshalMap(result.Item, &ret); err != nil {
		return nil, false, fmt.Errorf("unmarshaling user %s: %v", *userid, err)
	}

	return &ret, true, nil
}

func (d *DynamoStore) PutUser(ctx context.Context, u *DynamoWebauthnUser) (id string, err error) {
	tis := []*dynamodb.TransactWriteItem{}

	if u.ID == "" {
		// new user. give it an ID, and insert it along with the email record,
		// to ensure it's unique on creation
		u.ID = uuid.NewString()

		item, err := dynamodbattribute.MarshalMap(u)
		if err != nil {
			return "", fmt.Errorf("marshaling user: %v", err)
		}

		tis = append(tis, []*dynamodb.TransactWriteItem{
			{
				Put: &dynamodb.Put{
					TableName: &d.webauthnUserTableName,
					Item:      item,
				},
			},
			{
				// https://aws.amazon.com/blogs/database/simulating-amazon-dynamodb-unique-constraints-using-transactions/
				Put: &dynamodb.Put{
					TableName: &d.webauthnUserTableName,
					Item: map[string]*dynamodb.AttributeValue{
						"id": {
							S: aws.String(emailKey(u.Email)),
						},
						userIdAttribute: {
							S: &u.ID,
						},
					},
					ConditionExpression: aws.String("attribute_not_exists(id)"),
				},
			}}...)
	} else {
		// user already exists. fetch the db record, and see if email changed
		dbu, ok, err := d.GetUserByID(ctx, u.ID)
		if err != nil {
			return "", fmt.Errorf("getting existing user from DB: %v", err)
		}
		if !ok {
			return "", fmt.Errorf("user %s was not found in datastore", u.ID)
		}

		item, err := dynamodbattribute.MarshalMap(u)
		if err != nil {
			return "", fmt.Errorf("marshaling user: %v", err)
		}

		if dbu.Email != u.Email {
			// we're changing email address. remove the existing email reference first
			tis = append(tis, []*dynamodb.TransactWriteItem{
				{
					Delete: &dynamodb.Delete{
						TableName: &d.webauthnUserTableName,
						Key: map[string]*dynamodb.AttributeValue{
							"id": {
								S: aws.String(emailKey(dbu.Email)),
							},
						},
					},
				},
				{
					Put: &dynamodb.Put{
						TableName: &d.webauthnUserTableName,
						Item: map[string]*dynamodb.AttributeValue{
							"id": {
								S: aws.String(emailKey(u.Email)),
							},
							userIdAttribute: {
								S: &u.ID,
							},
						},
						ConditionExpression: aws.String("attribute_not_exists(id)"),
					},
				}}...)
		}
		// email change or not, put the updated user too
		tis = append(tis, &dynamodb.TransactWriteItem{
			Put: &dynamodb.Put{
				TableName: &d.webauthnUserTableName,
				Item:      item,
			},
		})
	}

	if _, err := d.client.TransactWriteItemsWithContext(ctx, &dynamodb.TransactWriteItemsInput{
		TransactItems: tis,
	}); err != nil {
		return "", fmt.Errorf("putting user: %v", err)
	}

	return u.ID, nil
}

func (d *DynamoStore) ListUsers(ctx context.Context) ([]*DynamoWebauthnUser, error) {
	result, err := d.client.ScanWithContext(ctx, &dynamodb.ScanInput{
		TableName: &d.webauthnUserTableName,
	})
	if err != nil {
		return nil, fmt.Errorf("scanning users: %v", err)
	}
	ret := []*DynamoWebauthnUser{}
	for _, i := range result.Items {
		if strings.HasPrefix(*i["id"].S, emailKeyPrefix) {
			continue
		}
		u := DynamoWebauthnUser{}
		if err := dynamodbattribute.UnmarshalMap(i, &u); err != nil {
			return nil, fmt.Errorf("unmarshaling user %s: %v", *i["id"].S, err)
		}
		ret = append(ret, &u)
	}

	return ret, nil
}

func (d *DynamoStore) DeleteUser(ctx context.Context, id string) error {

	// fetch user so we know the email to delete
	dbu, ok, err := d.GetUserByID(ctx, id)
	if err != nil {
		return fmt.Errorf("getting existing user from DB: %v", err)
	}
	if !ok {
		// already gone
		return nil
	}

	tis := []*dynamodb.TransactWriteItem{
		{
			Delete: &dynamodb.Delete{
				TableName: &d.webauthnUserTableName,
				Key: map[string]*dynamodb.AttributeValue{
					"id": {
						S: aws.String(emailKey(dbu.Email)),
					},
				},
			},
		},
		{
			Delete: &dynamodb.Delete{
				TableName: &d.webauthnUserTableName,
				Key: map[string]*dynamodb.AttributeValue{
					"id": {
						S: &id,
					},
				},
			},
		},
	}

	if _, err := d.client.TransactWriteItemsWithContext(ctx, &dynamodb.TransactWriteItemsInput{
		TransactItems: tis,
	}); err != nil {
		return fmt.Errorf("deleting user: %v", err)
	}

	return nil
}

// emailKey is the table ID record for a given email address, to enforce it's
// uniqueness and map it to a user
func emailKey(email string) string {
	return emailKeyPrefix + email
}
